# streamlit_app.py
import streamlit as st
import pandas as pd
import matplotlib.pyplot as plt
import numpy as np

# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# ê¸°ë³¸ ì„¤ì •
# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
st.set_page_config(page_title="LogicLab: GateBox", page_icon="ğŸ”Œ", layout="wide")

# ìƒíƒœ ì´ˆê¸°í™”
if "score" not in st.session_state:
    st.session_state.score = 0
if "q_index" not in st.session_state:
    st.session_state.q_index = 0
if "wrong" not in st.session_state:
    st.session_state.wrong = []

# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# ê²Œì´íŠ¸ ì •ì˜
# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
def AND(a, b):  return int(a and b)
def OR(a, b):   return int(a or b)
def NOT(a):     return int(0 if a else 1)
def NAND(a, b): return NOT(AND(a, b))
def NOR(a, b):  return NOT(OR(a, b))
def XOR(a, b):  return int((a and not b) or (not a and b))
def XNOR(a, b): return NOT(XOR(a, b))

GATE_FUNCS = {
    "AND":  lambda a, b: AND(a, b),
    "OR":   lambda a, b: OR(a, b),
    "NOT(A)": lambda a, b: NOT(a),
    "NOT(B)": lambda a, b: NOT(b),
    "NAND": lambda a, b: NAND(a, b),
    "NOR":  lambda a, b: NOR(a, b),
    "XOR":  lambda a, b: XOR(a, b),
    "XNOR": lambda a, b: XNOR(a, b),
}

BASIC_GATES = ["AND", "OR", "NAND", "NOR", "XOR", "XNOR", "NOT(A)", "NOT(B)"]

# ì§„ë¦¬í‘œ ìƒì„±
def truth_table(gate_name):
    rows = []
    for a in [0,1]:
        for b in [0,1]:
            y = GATE_FUNCS[gate_name](a, b)
            rows.append({"A": a, "B": b, f"{gate_name}": y})
    return pd.DataFrame(rows)

# í˜„ì¬ ì…ë ¥í–‰ ë§ˆí‚¹
def mark_current(df, a, b):
    df = df.copy()
    df.insert(0, "â–¶", ["â—»" for _ in range(len(df))])
    idx = (df["A"] == a) & (df["B"] == b)
    df.loc[idx, "â–¶"] = "â–¶"
    return df

# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# ì‚¬ì´ë“œë°”
# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
st.sidebar.title("LogicLab: GateBox")
page = st.sidebar.radio("í˜ì´ì§€", ["ê²Œì´íŠ¸ ë·°ì–´", "íƒ€ì„ë¼ì¸", "2ë‹¨ í•©ì„±", "í€´ì¦ˆ", "ëŒ€ì‹œë³´ë“œ"])

st.sidebar.caption("â“˜ 2í•™ë…„ ë„ì œë°˜ ë…¼ë¦¬íšŒë¡œ ë„ì…/ì‹¤ìŠµ í™•ì¸ìš©")

# ê³µí†µ ì…ë ¥
st.sidebar.markdown("### ì…ë ¥ ìŠ¤ìœ„ì¹˜")
A = st.sidebar.toggle("A", value=False)
B = st.sidebar.toggle("B", value=False)
A_i, B_i = int(A), int(B)

# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# 1) ê²Œì´íŠ¸ ë·°ì–´
# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
if page == "ê²Œì´íŠ¸ ë·°ì–´":
    st.header("ğŸ” ê²Œì´íŠ¸ ë·°ì–´ (ì…ë ¥â†’ì¶œë ¥ ì§ê´€)")
    gate = st.selectbox("ê²Œì´íŠ¸ ì„ íƒ", BASIC_GATES, index=0, key="viewer_gate")

    out = GATE_FUNCS[gate](A_i, B_i)
    col1, col2 = st.columns([1,1])

    with col1:
        st.subheader("ì…/ì¶œë ¥ íŒ¨ë„")
        st.write(f"**A:** `{A_i}`  |  **B:** `{B_i}`")
        led = "ğŸŸ¢ ON" if out == 1 else "âš« OFF"
        st.metric(label=f"ì¶œë ¥ {gate}", value=f"{out} ({led})")

    with col2:
        st.subheader("ì§„ë¦¬í‘œ")
        df = truth_table(gate)
        dfm = mark_current(df, A_i, B_i)
        st.dataframe(dfm, use_container_width=True, hide_index=True)

    st.info("íŒ: A/Bë¥¼ í† ê¸€í•´ ë³´ë©´ì„œ LED ë°˜ì‘ê³¼ ì§„ë¦¬í‘œ í•˜ì´ë¼ì´íŠ¸(â–¶)ë¥¼ ë™ì‹œì— í™•ì¸í•˜ì„¸ìš”.")

# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# 2) íƒ€ì„ë¼ì¸ (íŒŒí˜• ì‹œê°í™”)
# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
elif page == "íƒ€ì„ë¼ì¸":
    st.header("ğŸ•’ íƒ€ì„ë¼ì¸ (ì‚¬ê°íŒŒ â†’ ì¶œë ¥ íŒŒí˜•)")
    colL, colR = st.columns([1,1])

    with colL:
        gate = st.selectbox("ê²Œì´íŠ¸ ì„ íƒ", BASIC_GATES, index=6, key="timeline_gate")
        n_cycles = st.slider("ìƒ˜í”Œ ê¸¸ì´", 8, 64, 16, step=2)
        duty_A = st.slider("A ë“€í‹°(%)", 0, 100, 50, step=5)
        duty_B = st.slider("B ë“€í‹°(%)", 0, 100, 50, step=5)
        phase_B = st.slider("B ìœ„ìƒ ì§€ì—°(ìƒ˜í”Œ)", 0, n_cycles-1, 0)
        st.caption("ë“€í‹°ëŠ” 1ì˜ ë¹„ìœ¨, ìœ„ìƒ ì§€ì—°ì€ Bì˜ ì‹œì‘ ìœ„ì¹˜ë¥¼ ë°€ì–´ì¤ë‹ˆë‹¤.")

    # íŒŒí˜• ìƒì„±
    def square_wave(n, duty, phase=0):
        arr = np.zeros(n, dtype=int)
        on_len = int(n * (duty/100))
        start = phase % n
        arr[start:start+on_len if start+on_len <= n else n] = 1
        if start+on_len > n:
            arr[:(start+on_len) % n] = 1
        return arr

    A_w = square_wave(n_cycles, duty_A, 0)
    B_w = square_wave(n_cycles, duty_B, phase_B)
    Y_w = np.array([GATE_FUNCS[gate](int(a), int(b)) for a, b in zip(A_w, B_w)])

    with colR:
        fig = plt.figure(figsize=(7,3))
        t = np.arange(n_cycles)
        plt.step(t, A_w+2, where="post", label="A +2")
        plt.step(t, B_w+1, where="post", label="B +1")
        plt.step(t, Y_w+0, where="post", label=f"Y={gate}")
        plt.yticks([0,1,2,3], ["0","1","B","A"])
        plt.xlabel("ìƒ˜í”Œ")
        plt.ylim(-0.5, 3.5)
        plt.legend(loc="upper right")
        plt.grid(True, linestyle="--", alpha=0.3)
        st.pyplot(fig, use_container_width=True)

    st.success("XORì„ ì„ íƒí•˜ê³  B ìœ„ìƒì„ ì•½ê°„ ë°€ì–´ë³´ì„¸ìš”. ë‘ ì…ë ¥ì´ ë‹¤ë¥¼ ë•Œë§Œ ì¶œë ¥ì´ 1ì´ ë˜ëŠ” ê±¸ íŒŒí˜•ìœ¼ë¡œ ì§ê´€í™”í•  ìˆ˜ ìˆì–´ìš”.")

# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# 3) 2ë‹¨ í•©ì„± (ê°„ë‹¨ ì¡°í•©ë…¼ë¦¬ ë¹Œë”)
# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
elif page == "2ë‹¨ í•©ì„±":
    st.header("ğŸ§± 2ë‹¨ í•©ì„± (G1(A,B) âŠ• G2(A,B))")
    c1, c2, c3 = st.columns([1,1,1])

    with c1:
        g1 = st.selectbox("1ë‹¨ ê²Œì´íŠ¸ G1", BASIC_GATES, index=0)
    with c2:
        comb = st.selectbox("ê²°í•© ê²Œì´íŠ¸", ["AND","OR","XOR","XNOR","NAND","NOR"])
    with c3:
        g2 = st.selectbox("1ë‹¨ ê²Œì´íŠ¸ G2", BASIC_GATES, index=1)

    G1 = GATE_FUNCS[g1](A_i, B_i)
    G2 = GATE_FUNCS[g2](A_i, B_i)
    Y  = GATE_FUNCS[comb](G1, G2)

    st.write(f"**ì…ë ¥** A={A_i}, B={B_i} â†’  **G1={g1}â†’{G1}**, **G2={g2}â†’{G2}**, **ê²°í•©={comb}â†’Y={Y}**")
    st.metric("ìµœì¢… ì¶œë ¥ Y", Y)

    # ê°„ë‹¨ ê·¸ë˜í”„(ASCII ìŠ¤íƒ€ì¼) â€“ Streamlit ê¸°ë³¸ë§Œ ì‚¬ìš©
    st.caption("êµ¬ì¡°: A,B â†’ G1/G2 â†’ ê²°í•©ê²Œì´íŠ¸ â†’ Y")
    df_tt = pd.DataFrame(
        [{"A":a,"B":b,"G1":GATE_FUNCS[g1](a,b),"G2":GATE_FUNCS[g2](a,b),
          f"Y={comb}(G1,G2)":GATE_FUNCS[comb](GATE_FUNCS[g1](a,b), GATE_FUNCS[g2](a,b))}
         for a in [0,1] for b in [0,1]]
    )
    st.dataframe(mark_current(df_tt, A_i, B_i), use_container_width=True, hide_index=True)

    st.info("í™œë™ ì•„ì´ë””ì–´: (A NAND B) OR (NOT A)ì²˜ëŸ¼ êµ¬ì„±í•œ ë’¤, ì–´ë–¤ ì…ë ¥ ì¡°í•©ì—ì„œ 1ì´ ë˜ëŠ”ì§€ ì°¾ì•„ë³´ë„ë¡ ë¯¸ì…˜ì„ ë¶€ì—¬í•˜ì„¸ìš”.")

# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# 4) í€´ì¦ˆ
# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
elif page == "í€´ì¦ˆ":
    st.header("ğŸ“ ê°œë… í™•ì¸ í€´ì¦ˆ")

    questions = [
        {
            "type":"OX",
            "q":"NANDë§Œìœ¼ë¡œ ëª¨ë“  ê¸°ë³¸ ê²Œì´íŠ¸(AND/OR/NOT ë“±)ë¥¼ ë§Œë“¤ ìˆ˜ ìˆë‹¤.",
            "ans":"O",
            "exp":"NANDëŠ” ê¸°ëŠ¥ì ìœ¼ë¡œ ì™„ì „(Functional completeness)í•©ë‹ˆë‹¤."
        },
        {
            "type":"MC",
            "q":"ë‹¤ìŒê³¼ ë™ì¹˜ì¸ ê²Œì´íŠ¸ëŠ”?  Â¬(A Â· B)",
            "choices":["NOR","XOR","NAND","XNOR"],
            "ans":"NAND",
            "exp":"Â¬(AÂ·B)ëŠ” NANDì˜ ì •ì˜ì™€ ë™ì¼í•©ë‹ˆë‹¤."
        },
        {
            "type":"MC",
            "q":"XOR ì¶œë ¥ì´ 1ì´ ë˜ëŠ” ê²½ìš°ëŠ”?",
            "choices":["A=B", "Aâ‰ B", "í•­ìƒ 0", "í•­ìƒ 1"],
            "ans":"Aâ‰ B",
            "exp":"XORì€ ë‘ ì…ë ¥ì´ ë‹¤ë¥¼ ë•Œ 1ì…ë‹ˆë‹¤."
        },
        {
            "type":"MC",
            "q":"NOR ê²Œì´íŠ¸ì˜ ì§„ë¦¬í‘œì—ì„œ 1ì´ ë˜ëŠ” ê²½ìš°ëŠ”?",
            "choices":["A=0,B=0","A=1,B=0","A=0,B=1","A=1,B=1"],
            "ans":"A=0,B=0",
            "exp":"NORì€ ORì˜ ë¶€ì •ì´ë¯€ë¡œ ë‘ ì…ë ¥ì´ ëª¨ë‘ 0ì¼ ë•Œë§Œ 1ì…ë‹ˆë‹¤."
        },
        {
            "type":"MC",
            "q":"XNORì˜ ì˜ë¯¸ì™€ ê°€ì¥ ê°€ê¹Œìš´ ê²ƒì€?",
            "choices":["ë™ì¹˜","í•©","ê³±","ë¶€ì •"],
            "ans":"ë™ì¹˜",
            "exp":"XNORì€ Aì™€ Bê°€ ê°™ì„ ë•Œ 1 â†’ ë…¼ë¦¬ì  ë™ì¹˜ì…ë‹ˆë‹¤."
        },
    ]

    q = questions[st.session_state.q_index % len(questions)]
    st.subheader(f"Q{st.session_state.q_index % len(questions) + 1}. {q['q']}")

    if q["type"] == "OX":
        sel = st.radio("ì„ íƒ", ["O","X"], horizontal=True)
    else:
        sel = st.radio("ì„ íƒ", q["choices"], index=0)

    colA, colB = st.columns([1,3])
    with colA:
        if st.button("ì œì¶œ"):
            if sel == q["ans"]:
                st.session_state.score += 1
                st.success("ì •ë‹µ! âœ…")
            else:
                st.session_state.wrong.append({"ë¬¸í•­": q["q"], "ì„ íƒ": sel, "ì •ë‹µ": q["ans"]})
                st.error("ì˜¤ë‹µ âŒ")
            st.info(q["exp"])
    with colB:
        if st.button("ë‹¤ìŒ ë¬¸í•­"):
            st.session_state.q_index += 1
            st.experimental_rerun()

    st.divider()
    st.metric("ëˆ„ì  ì ìˆ˜", st.session_state.score)
    if st.session_state.wrong:
        st.write("**ì˜¤ë‹µë…¸íŠ¸**")
        st.dataframe(pd.DataFrame(st.session_state.wrong), use_container_width=True, hide_index=True)

# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# 5) ëŒ€ì‹œë³´ë“œ (ìš”ì•½/ê°€ì´ë“œ)
# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
elif page == "ëŒ€ì‹œë³´ë“œ":
    st.header("ğŸ“Š ìˆ˜ì—… ëŒ€ì‹œë³´ë“œ & ì‚¬ìš© ê°€ì´ë“œ")
    st.write("- ë„ì…: **ê²Œì´íŠ¸ ë·°ì–´**ì—ì„œ A/B í† ê¸€ â†’ ì¶œë ¥ ì§ê´€")
    st.write("- ê°œë…: **íƒ€ì„ë¼ì¸**ìœ¼ë¡œ XOR ë“± íŒŒí˜• ì§ê´€")
    st.write("- ì‹¤ìŠµ: **2ë‹¨ í•©ì„±**ìœ¼ë¡œ ê°„ë‹¨ ì¡°í•©ë…¼ë¦¬ êµ¬ì„±")
    st.write("- í™•ì¸: **í€´ì¦ˆ** 5~7ë¬¸í•­, ì˜¤ë‹µë…¸íŠ¸ í™œìš©")
    st.info("ë°œí‘œëŠ” ì‹œì—° 3ë¶„ + ì„¤ëª… 4ë¶„ êµ¬ì„±. ì œì¶œë¬¼: Streamlit URL + ê¸°íšì„œ/ìˆ˜ì—…ì•ˆ PDF")
